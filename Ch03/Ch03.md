
# Zero to 60 with RavenDB, from installation to usage

In this chapter, we will install RavenDB and start working with it. Before we can get started with RavenDB, we need to have a live instance that we can work with. There are several ways to run RavenDB:

* Development - console mode
* Production
    * Windows Service
    * IIS
* In the cloud - [RavenHQ](http://www.ravenhq.com)

The console mode is very useful for development, because you can see the incoming requests to RavenDB, and you can interact with the server directly. For production usage, you can install RavenDB as a Windows Service or in IIS. We'll discuss the relative merits of each option toward the end of this chapter. 

For running in the cloud, you can use the RavenDB as a Service option provided by [RavenHQ](http://www.ravenhq.com). You can read more on RavenHQ in Chapter TODO, for now, we'll focus on everything you need to get RavenDB running on your own machine.

## Setting up everything

Go to the [RavenDB download page](http://ravendb.net/download), and download the latest version. At the time of this writing, this is version 3.0. You should download the zip archive and extract it. Then go to the Start.cmd file and double click it.
This will start RavenDB in console (debug) mode as well as open your browser to point to the RavenDB Management Studio^[The acronym for the studio is RDBMS.]. 

Note the URL in the browser. By default, RavenDB will try to use http://localhost:8080 as its endpoint. But if you have a service already taking this port, it might select port 8081, etc. If you are not running as an administrator, RavenDB will ask you to authorize access to the relevant HTTP port. 

The studio will ask you to create a database, please name the database Northwind, and press the Create button. You can ignore the bundles selection for now, we'll discuss them at length later.
Now that we have a database, go to the Tasks tab and then to Create Sample Data dialog, press the Create Sample Data button. You should see a progress bar running for a short while, and now you have a new database, including data that we can play with.

> The Northwind database is the sample database that came with SQL Server, it has been used for decades as _the_ sample database in the Microsoft community. We choose this database as our sample data because it is likely already familiar to you in its relational format.

Go to the Documents tab and then select the Products collection on the left. You should see something similar to Figure 1.

![The Products collection in the Northwind database](.\Ch03\Figure01.png)

This looks remarkably similar to what you'll see in a relational database. The data is shown in grid format, and we have the "tables" on the left. If you click on one of the products (the link is on the left most column), you'll enter into the actual document view, as shown in Figure 2.

![Editing a product document in the RavenDB Studio](.\Ch03\Figure02.png)

Now we can actually see the JSON data of the documents. But products are pretty simple documents, pretty much a one to one translation from the relational model. Let us look at a more interesting example. Let us go to orders/827, you can use the Go To Document text box at the top of the studio to go directly there. The content of that document is shown is Listing 3.1.

You can see several interesting things in Listing 3.1. We no longer have a simple key/value model that matches exactly to the column values in the relational model. We can aggregate related information into a common object, as in the case of the ShipTo property which has all of the shipping information. 

But probably even more important is the way we are handling the line items. In the relational schema, those were relegated to a separate table. And loading the order's data would require us to join to that table. Here all of the order information, including the collection of line items are included directly in the document.

We'll discuss this at length when we talk about modeling in Chapter 3, but as you can imagine at this early stage, this capability significantly reduces both complexity and cost of getting the data from the database.

```{caption="The orders/827 document" .json }   
{
    "Company": "companies/73",
    "Employee": "employees/7",
    "OrderedAt": "1998-05-06T00:00:00.0000000",
    "RequireAt": "1998-06-03T00:00:00.0000000",
    "ShippedAt": null,
    "ShipTo": {
        "Line1": "VinbÃ¦ltet 34",
        "Line2": null,
        "City": "Kobenhavn",
        "Region": null,
        "PostalCode": "1734",
        "Country": "Denmark"
    },
    "ShipVia": "shippers/2",
    "Freight": 18.44,
    "Lines": [
        {
            "Product": "products/16",
            "ProductName": "Pavlova",
            "PricePerUnit": 17.45,
            "Quantity": 14,
            "Discount": 0.05
        }
    ]
}
```

We'll not be going through all the things that you can do with the studio. Instead, we'll refer back to those whenever we want to show you something new or interesting that has relevancy in the studio as well (the operational monitoring capabilities, visualization of work, etc.).

Now that we have a running system, feel free to explore it a bit, and then we'll move to the fun part, using RavenDB in our application.

## Coding with RavenDB

Start Visual Studio and create a new Console Application Project named `Northwind`. Then, in the Package Manager Console, issue the following command:

	Install-Package RavenDB.Client

This command uses NuGet to get the RavenDB Client package and add a reference to it to your project. Now we just need to tell the client where the server is located. Add a using statement for `Raven.Client.Document`, and then create a document store, like so:

	var documentStore = new DocumentStore
	{
		Url = "http://localhost:8080",
		DefaultDatabase = "Northwind"
	};

	documentStore.Initialize();

> Note that if your RavenDB server is running on a different port, you'll need to change the document store's URL.

The document store is the starting point for all your interactions with RavenDB. If you have used NHibernate in the past, the DocumentStore is very similar to the SessionFactory. We use the document store to create sessions, which is how we usually read and write data from RavenDB.

	using (var session = documentStore.OpenSession())
	{
		var p = session.Load<dynamic>("products/1");
		Console.WriteLine(p.Name);
	}

You can see that we didn't have to define anything, we can immediately start working with RavenDB. The schema less nature of RavenDB, combined with the dynamic option in C# allows us to work in a completely dynamic world. But for most things, we actually do want some structure. 
Our next step would be to introduce the model classes to our project. In the studio, go to the Tasks tab, then to the Create Sample Data dialog. Press the Show Sample Data Classes button, and copy the resulting text to Visual Studio. Listing 3.2 shows the Product sample data class.

```{caption="The sample Product class" .cs }   
public class Product
{
	public string Id { get; set; }
	public string Name { get; set; }
	public string Supplier { get; set; }
	public string Category { get; set; }
	public string QuantityPerUnit { get; set; }
	public decimal PricePerUser { get; set; }
	public int UnitsInStock { get; set; }
	public int UnitsOnOrder { get; set; }
	public bool Discontinued { get; set; }
	public int ReorderLevel { get; set; }
}
```

You can see that there really isn't anything special about this class. There is no special base class, attributes or even the requirement that the class would have virtual members. This is a Plain Old C# Object in its purest form. How do we use this class? Here is the same code as before, but using the Product class instead of dynamic.

	using (var session = documentStore.OpenSession())
	{
		var p = session.Load<Product>("products/1");
		Console.WriteLine(p.Name);
	}

We load the product by id, then print out its name. It Just Works.

## The basics of the client API

So far, we have setup RavenDB, explored the studio, wrote some code to connect to RavenDB, pulled data out and defined strongly typed classes that allowed us to work with RavenDB more easily.
This is all well and good, but as fun as blind experimentation is, we need to understand what is going on in order to do great things with RavenDB.

### The document store

You've already used the document store to talk to RavenDB, but what is its purpose? The document store holds the RavenDB URL, the default database we'll talk to and the credentials that will be used. It is the first thing that we create when we need to talk to RavenDB. But its importance extends beyond just knowing who to talk to.

The document store holds all the client side configuration for RavenDB, how we are going to serialize your entities, how to handle failure scenario, what sort of caching strategy to use, and much more. In typical application, you shall have a single document store instance per application (singleton). Because of that, the document store is thread safe, and a typical initialization pattern looks like Listing 3.3.

```{caption="Common pattern for initialization of the DocumentStore" .cs }   
public class DocumentStoreHolder
{
	private readonly static Lazy<IDocumentStore> _store = 
		new Lazy<IDocumentStore>(CreateDocumentStore);

	private static IDocumentStore CreateDocumentStore()
	{
		var documentStore = new DocumentStore
		{
			Url = "http://localhost:8080",
			DefaultDatabase = "Northwind",
		};

		documentStore.Initialize();
		return documentStore;
	}

	public static IDocumentStore Store
	{
		get { return _store.Value; }
	}
}
```

The use of Lazy ensures that the document store is only created once, without having to worry about double locking or explicit thread safety issues. And we can configure the document store as we see it. The rest of the code has access to the document store using `DocumentStoreHolder.Store`. That should be relatively rare, since apart from configuring the document store, the majority of the work is done using sessions.
But before we get to that, let us see what sort of configuration we can do with the document store.

#### Conventions

The RavenDB Client API, just like the rest of RavenDB, aims to Just Work. As a result of that, it is based around the notion of conventions. A series of policy decisions that has already been made for you. Those range from deciding which property holds the document id to how the entity should be serialized to a document.

For the most part, we expect that you'll not have to touch the conventions. A lot of thought and effort has gone into ensuring that you'll have no need to do that. But there is simply no way that we can foresee the future, or answer every need, which is what pretty much every part of the client API is customizable.

Most of that is handled via the `DocumentStore.Conventions` property, by registering your own behavior. For example, by default the RavenDB Client API will use a property named `Id` (case sensitive) to store the document id. But there are users who want to use the entity name as part of the property name. So we'll have OrderId for orders, ProductId for products, etc.^[I'll leave aside Id vs. ID, since it is handled in the same manner].

Here is how we can tell the RavenDB Client API that it should use this behavior:

	documentStore.Conventions.FindIdentityProperty = 
		prop => prop.Name == prop.DeclaringType.Name + "Id";

I'm not going to go over each option in the conventions since there are literally dozens of them. There are API comments on each of the exposed options, and it is probably worth your time to go and peruse through them, even if for the most part, they aren't really something that you'll touch.

Other options that can be controlled via the document store are request timeout, caching configuration, creating indexes and transformers, setting up listeners, listening to changes and doing bulk inserts into RavenDB. We'll cover those further into this book.

#### Connection strings

You might have noticed that when we defined the document store so far, we have done so using hard code URL and database, like so:

	var documentStore = new DocumentStore
	{
		Url = "http://localhost:8080",
		DefaultDatabase = "Northwind",
	};

This is great when we just want to play around, but it isn't really suitable for actually working with RavenDB on a day to day basis. Different environments have different URLs, databases and credentials. In here, RavenDB makes no attempt to invent the wheel and it uses connection strings to specify all the details. The following code snippet shows how to configure RavenDB using a connection string:

	var documentStore = new DocumentStore
	{
		ConnectionStringName = "RavenDB"
	};

This code instructs the document store to go and look at the <connectionStrings> element in the web.config (or app.config) files. Listing 3.4 shows a sample of a few such connection strings:

```{caption="RavenDB Connection Strings" .xml }   
<connectionStrings>
  <add name="RavenDB" connectionString="
    Url=http://localhost:8080;
	Database=Northwind;ApiKey=MyApp/1hjd14hdfs" />

  <add name="Another" connectionString="
	Url=http://localhost:8080;
	User=beam;Password=up;Database=Scotty" />

	<add name="Embedded" connectionString="DataDir=~\Northwind" />
</connectionStrings>
```

In this manner, you can modify which server and database your client application will talk to by just modifying the configuration. You might also have noticed that we have an embedded connection string as well, what is that?

#### Document store types

RavenDB can run in several modes. The most obvious one is when you run it as a console application and communicate with it over the network. In production, you do pretty much the same thing, except that you'll run RavenDB in IIS or as a Windows Service. This is great for building server applications, where you want independent access to your database, but there are other options with RavenDB.

You can run RavenDB as part of your application, embedded inside your own process. If you want to do that, just use the `EmbeddableDocumentStore` class, instead of `DocumentStore`. You can even configure the `EmbeddableDocumentStore` to talk to a remote server or an embedded database just by changing the connection string.
The main advantage of using an embedded RavenDB instance is that you don't need separate deployment or administration. There is also no need to traverse the network to access the data, since it lives inside the same process as you own application.

This option is particularly attractive for teams building low overhead system or business applications that are deployed client side. [Octopus Deploy](https://octopusdeploy.com/) is an automated deployment system that makes use of RavenDB in just such a manner. Even if you use it, you're probably not aware that it is using RavenDB behind the scenes, since that is all internal to the application.

On the other side, you have [NServiceBus](http://www.NServiceBus.com), which also makes heavy use of RavenDB, but usually does so in a server mode. So you'll install RavenDB as part of your NServiceBus deployment and manage it as an independent service. 

From coding perspective, there is very little difference between the two. In fact, even in embedded mode, you are going through the same exact code paths you'll be going when talking to a remote database, except that there is no networking involved.

#### Authentication

A database holds a lot of information, and usually it is pretty important that you'll have control over who can access that information and what they can do with that. RavenDB fully supports this notion.

In development mode, you'll usually work with the `Raven/AnonymousAccess` setting set to `Admin`. In other words, any access to the database will be considered to be an access by an administrator. This reduces the number of things that you have to do upfront. But as easy as that is for development, for production, we set that setting to be `None`. This option requires all access to the database server^[Note that this is a server level option, rather than a database level option] to be done only by authenticated users.

Users can be authenticated in one of two ways. Either using Windows Authentication via user/pass/domain credentials or using OAuth via an API Key^[You can think about this as Windows Authentication and SQL Authentication in SQL Server]. You can configure access to RavenDB by going to the Databases page in the Studio (click on the link at the top right corner), then selecting the System Database (on the right of the page). Now got to the Settings tab.

Here you can see the options for configuring access. In large organizations, it is very common to want to run all authentication through Active Directory, because that lets the operations team have centralized control over all the users.
You can select Windows Authentication and then add a new user or group, and grant them access to specific databases. You can also grant access to all databases by using an asterisk (*) as the database name. The asterisk does not include access to the system database, you need to configure that independently.

Even though using Windows Authentication is quite common, I really like using API Keys, instead. You can see how we configure API Keys in Figure 3. I've had quite a few issues with relying on Active Directory to really feel comfortable with it. Mostly because of... interesting policies that the organizations defined. From password expiration every 3 months that takes down systems whose configurations haven't been updated to deleting "inactive" user accounts that takes down systems to ... I'm sure you get the point.

![Configuring API Keys access](.\Ch03\Figure03.png)

The good thing about API Keys is that they are _not_ users. They are not tied to a specific person or need to be managed as such. Instead, they represent specific access that was granted to the database for a particular reason. On Figure 3 you can see that read/write access was granted to the Northwind database for the OrdersApp API Key. I find that this is a much more natural way to handle authentication.

Regardless of the authentication method that was chosen, you can control the level of access to a database by granting read-only, read/write or admin permissions. Read-only and read/write are quite obvious, but what does it mean, to have admin privileges on a database?

#### Administrators

Being an administrator means that you can perform operational actions such as perform a backup, stop/resume indexing, kill queries or background tasks, compact the database or force index optimizations. Those are all admin actions at the single database level. A user or API Key can be granted an admin level on a single database, or all of them (by specifying asterisk as the database name). That does not make them the _server_ administrators.

The server administrators are anyone in the Administrators group for the domain or for the local machine RavenDB is running on. In addition to those, the user account who is running RavenDB also have a server administrator permission for RavenDB. This last is done so you can run RavenDB on a least privilege account and still do administration work on the server without requiring you to be a system administrator.

You can also configure specific users or API Keys as the server administrators. That can be done by granting them admin permission on the <system> database. A server administrator can create or delete databases, change database settings, force garbage collection, collect stats from all databases and in general watch over everything that happens.

It is possible to define a server administrator that can manage the server, but has no access to the actual databases on that server. This is usually used in scenarios where regulatory compliance forbid even the administrators from being able to access the data on the server. Usually in such scenarios, the Encryption bundle is also used, but that will be discussed later in the book. (TODO: reference)

We have gone over all the major aspects of the document store, but we have neglect one small detail. The reason that the document store even exists is that we use it to create sessions, which actually interact with RavenDB. It's a good thing that this is what our next section is talking about.

### The session

The session (formally known as document session, but we usually shorten it to just a session) is the primary way your code interacts with RavenDB. If you are familiar with NHibernate or Entity Framework, you should feel right at home. The RavenDB session was explicitly modeled to make it easy to work with.

> **Terminology**
>
> We tend to use the term document to refer both to the actual documents on the server, and to manipulating them client side. It is common to say: "load that document and then... ". But occasionally we need to be more precise. 
> We make a distinction between a document and an entity (or aggregate root). A document is the server side representation, while an entity is the client side equivalent. An entity is the deserialized document that you work with client side, and save back to the database to become an updated document server side.

Let us start with the basics, writing and reading data with RavenDB. We create a session via the document store, and we can load a document using the surprisingly named method `Load`. We have already seen that we can use `dynamic` or one of our entity classes there. But how about modifying data? Take a look at Listing 3.5.

```{caption="Creating and modifying data in RavenDB" .numberLines .cs }  
// creating a new product
string productId;
using (var session = documentStore.OpenSession())
{
	var product = new Product
	{
		Category = "Awesome",
		Name = "RavenDB",
		Supplier = "Hibernating Rhinos",
	};
	session.Store(product);
	productId = product.Id;
	session.SaveChanges();
}

// loading & modifying the product
using (var session = documentStore.OpenSession())
{
	var p = session.Load<Product>(productId);
	p.ReorderLevel++;
	session.SaveChanges();
}
```

There are several interesting things in Listing 3.5. Look at the Store() call in in line 11, immediately after that call, we can already access the document id, even though we didn't save the change to the database yet. Next, on line 19, we load the entity from the document, update the entity and call SaveChanges(). 

The session is smart enough to understand that the entity has changed and update the matching document on the server side. You don't have to call Update() method, or anything of this sort. The session keeps track of all the entities you have loaded, and when you call SaveChanges(), all the changes to those entities are sent to the database _in a single remote call_.

> **Budgeting remote calls**

> Probably the easiest way to kill your application performance is to make a lot of remote calls. And the common culprit is the database. It is common to see application making tens of calls to the database, usually for no good reason. In RavenDB, we have done several things to mitigate that problem. The most important among them is to allocate a budget for every session. Typically a session would encompass a single operation in your system. An HTTP request or the processing of a single message is usually the lifespan of a session.
>
> And a session is limited by default to a maximum of 30 calls to the server. If you try to make more than 30 calls to the server, an exception is thrown. This serves as an early warning that your code is generating too much load on the system and as a Circuit Breaker^[See [Release It!](http://pragprog.com/book/mnee/release-it), a wonderful book that heavily influenced the RavenDB design].
> You can increase the budget, of course, but just having that in place ensures that you will think about the number of remote calls that you are making.
>
> The limited number of calls allowed per session also means that RavenDB has a lot of options to _reduce_ the number of calls. When you call SaveChanges(), we don't need to make a separate call per changed entity, we can go to the database once.
In the same manner, we also allow to batch _read_ calls. We'll discuss it in the next chapter, on the Lazy section.

One of the main design forces behind RavenDB was the idea that it should Just Work. And the client API reflect that principle. If you look at the surface API for the session, there are the following high level options:

* Load()
* Include()
* Delete()
* Query()
* Store()
* SaveChanges()
* Advanced

Those are the most common operations that you'll run into on a day to day basis. And more options are available in the Advanced property.

#### Load 

As the name implies, this gives you the option of loading a document or a set of documents into the session. A document loaded into the session is managed by the session, any changes made to the document would be persisted to the database when you call `SaveChanges`. A document can only be loaded once in a session. Let's look at the following code:

	var p1 = session.Load<Product>("products/1");
	var p2 = session.Load<Product>("products/1");

	Assert.True(Object.ReferenceEquals(p1,p2));

Even though we call `Load<Product>("products/1")` twice, there is only a single remote call to the server, and only a single instance of the Product class. Whenever a document is loaded, it is added to an internal dictionary that the session manages. Whenever you load a document, the session check in that dictionary to see if that document is already there, and if so, it will return the existing instance immediately. This helps avoid aliasing issues and also generally helps performance.

For those of you who deals with patterns, the session implements the Unit of Work and Identity Map pattern. This is most obvious when talking about the `Load` operation, but it also applies to `Query` and `Delete`.

`Load` can also be used to read more than a single document at a time. For example, if I wanted three documents, I could use:

	Product[] products = session.Load<Product>(
		"products/1",
		"products/2",
		"products/3"
	);

This will result in an array with all three documents in it, retreived in a single remote call from the server. The positions in the array match the positions of the ids given to the `Load` call. 

You can even load documents belonging to multiple types in a single call, like so:

	object[] items = session.Load<object>(
		"products/1",
		"categories/2"
	);

	Product p = (Product)items[0];
	Category c = (Category)items[1];

A missing document will result in null being returned. Both for loading a single document and multiple documents (a null will be returned in the id position). The session will remember that couldn't load that document, and even if asked again, will immediately return null, rather than attempt to load the document again.

RavenDB ids are usually in some form of "collection" + "/" + number. This makes it very easy to look at and debug, but it does make them somewhat of a hassle to work with in web scenarios. That is especially true when dealing with web routes. Because of that, there is a simple convention that lets you use just the number as the document id.

	var product = session.Load<Product>(1);

This code is nice to use in web scenarios, because you can easily get an integer id from the web framework. It relies on a convention that matches Product class and the numeric id and generate the final document key: "products/1". 
You can modify this convention by modifying the  `store.Conventions.FindIdValuePartForValueTypeConversion` property. 

Even though you can load the document using just the numeric part, the actual document id is the full "products/1". This is merely a convenience feature, it doesn't change the way ids are handled.

#### Include

I previously mentioned that there is a budget for the number of remote calls that you can make from a session. Include is one of the chief ways to reduce the number of remote calls you are doing. We want to print a product, we can do it using the following code:

	var product = session.Load<Product>("products/1");
	Console.WriteLine("{0}: {1}", product.Id, product.Name);
	Console.WriteLine("Category: {0}", product.Category);

This code will have the following output:

	products/1: Chai
	Category: categories/1

I think that you will agree that this isn't a user friendly output. What we want is to print the category name and its description. In order to do that, we need to load it as well, like so:

	var product = session.Load<Product>("products/1");
	var cat = session.Load<Category>(product.Category);
	Console.WriteLine("{0}: {1}", product.Id, product.Name);
	Console.WriteLine("Category: {0}, {1}", 
		cat.Name, cat.Description);

Which gives us the much nicer output:

	products/1: Chai
	Category: Beverages, Soft drinks, coffees, teas, beers, and ales

This results in the right output, but we have to go to the server twice. That seems... unnecessary. We cannot use the `Load` overload that accepts multiple ids, because we don't know ahead of time what the value of the Category will be. What we can do is ask RavenDB to help us. We'll change the first line of code to be:
	
	var product = session.Include<Product>(x => x.Category)
		.Load("products/1");

The rest of the code will remain unchanged. This single change has profound effect on the way the system behaves because it tells the RavenDB server to do the following:

* Find a document with the key: "products/1"
* Read its "Category" property value.
* Find a document with that key.
* Send _both_ documents back to the client.

RavenDB can do that because the reply to a `Load` request has two channels to it. One channel for the actual results (products/1 document) and another for all the includes (categories/1 document).

The session knows how to read this included information and stores it separately. When the `Load<Category>("categories/1")` call is made, we can retrieve that data directly from the session cache, without having to go to the server. This can save us quite a bit on the number of remote calls we make.

> **Includes aren't joins**
> 
> It is tempting to think about Includes in RavenDB as similar to a join in a relational database. And there are similarities, but there are fundamental differences.
> A join will modify the shape of the output, it combines each match row from one side with each matching row on the other, sometimes creating Cartesian Products that are can cause night sweats for DBAs.
> 
> And the more complex your model, the more joins you'll have, the wider your result sets become, the slower your application will become. In RavenDB, there is very little cost to adding includes. That is because they operate on a different channel than the results of the operation. 
> 
> Includes are also important in queries, and there they operate _after_ paging has applied, instead of before paging, like joins. 
> 
> The end result is that Includes don't modify the shape of the output, don't have a high cost when you use multiple includes and don't suffer from problems like Cartesian Products.

You can also use multiple includes in a single call, like so:

	var product = session.Include<Product>(x => x.Category)
		.Include(x=>x.Supplier)
		.Load("products/1");

This will load both the category and the supplier documents into the session, in one shot. And more complex scenarios are also possible. Here is one such example:

	var order = session.Include<Order>(x => x.Company)
		.Include(x => x.Employee)
		.Include(x => x.Lines.Select(l => l.Product))
		.Load("orders/1");

This code will, in a single remote call, will load the order, include the company and employee documents, and also load _all_ the products in all the lines in the order. As you can see, this is a pretty powerful feature.

As powerful as it is, one of _the_ most common issues that we run into with RavenDB is people coming into RavenDB with a relational mindset, trying to use RavenDB as if it was a relational database and modeling their entities accordingly. Includes can help push you that way, because they let you get associated documents easily. 

We'll talk about modeling in a lot more depth in chapter 4, when you have learned enough about the kind of environment that RavenDB offers to make sense of the choices we make. For now, I'll point out that RavenDB does not support tertiary includes. That is, there is no way in RavenDB^[Not _quite_ true, you can use a transformer to do that, see [Chapter 5](#result-transfomers), but it isn't recommended to do so.] to load an order, its associated products through the order's lines as well as those products categories.

#### Delete

Deleting a document is done through the confusingly named method `Delete`. This method can accept an entity instance or a document id. The following are various ways to delete a document:

	var cat = session.Load<Category>("categories/1");
	session.Delete(cat);

	session.Delete<Product>(1);

	session.Delete("orders/1");

It is important to note that calling `Delete` doesn't actually delete the document. It merely marks that document as deleted in the session. It is only when `SaveChanges` is called that the document will be deleted. 

#### Query

Querying is a large part of what a database does. Not surprisingly, queries strongly relate to indexes, and we'll talk about those extensively in Chapter 5 and 6. In the meantime, let us see how we can query using RavenDB.

	List<Order> orders = (
			from o in session.Query<Order>()
			where o.Company == "companies/1")
			select o
		).ToList();

RavenDB is taking full advantage of LINQ support in C#. This allows us to express very natural queries on top of RavenDB in a strongly typed and safe manner.

Because we'll dedicate quite a bit of time to talking about queries and indexes later on, I'll be brief. Queries allow us to load documents that match a particular predicate. Like documents loaded via the `Load` call, documents that were loaded via a `Query` are managed by the session. Modifying them and calling `SaveChanges` will result in their update on the server.

And like the `Load` call, `Query` also supports include:

	List<Order> orders = (
			from o in session.Query<Order>()
							 .Include(x=>x.Company)
			where o.Company == "companies/1")
			select o
		).ToList();

You can now call `Load<Company>` on those companies and they will be served directly from the session cache. 

Queries in RavenDB don't behave like queries in a relational database. RavenDB does not allow computation during queries, and it doesn't have problems with table scans. We'll touch on exactly why and the details about indexing in the Chapters 5 and 6, but for now you can see that most queries will just work for you.

#### Store

The `Store` command is how you associate an entity with the session. Usually, this is done because you want to create a new document. We have already seen that in Listing 3.5, but here is the relevant part:

	Product p = new Product { ... };
	session.Store(p);
	string productId = p.Id;

Like the `Delete` command, `Store` will only actually save the document to the database when `SaveChanges` is called. However, it will give the new entity an id immediately, so you can refer to it in other documents that you'll save in the same batch. We'll discuss id generation strategies in Chapter 3.

Beyond saving a new entity, `Store` is also used to associate entities of existing documents with the session. This is common in web applications. You have one endpoint that sends the entity to the user, who modify that entity and then sends it back to your web application. You have a live entity instance, but it is not loaded by a session or tracked by it. 
At that point, you can call `Store` on that entity, and because it doesn't have a null document id, it will be treated as an existing document and overwrite the previous version on the database side.

`Store` can also be used in optimistic concurrency scenarios, but we'll talk about this in more details in Chapter 3.

#### SaveChanges

The `SaveChanges` call will check the session state for all deletions and changes, and send all of those to the server as a single remote call that will complete transactionally. In other words, either all the changes are saved as a single unit, or none of them do.

Remember that the session has an internal map of all the loaded entities. When you call `SaveChanges`, those loaded entities are checked against the entity as it was when it was loaded from the database. If there are any changes, that entity will be saved to the database.

It is important to understand that any change would force the entire entity to be saved. We don't attempt to make partial document updated in `SaveChanges`. An entity is always saved to a document as a single full change.

The typical way one would work with the session is:

	using (var session = documentStore.OpenSession())
	{
		// do some work with the session

		session.SaveChanges();
	}

So `SaveChanges` is called only once per session. In web scenarios, this is typically handled in the controller. Listing 3.6 shows an example of base RavenDB controllers for ASP.NET Web API and ASP.NET MVC. Both samples show a common pattern for working with RavenDB, we have the infrastructure (in this case, the base controller) take care of opening the session for us, as well as calling the `SaveChanges` method if there has been no errors.

```{caption="Base controllers classes for RavenDB" .cs }   
public abstract class BaseRavenDBController : Controller
{
	public IDocumentSession DocumentSession { get; set; }

	protected override void OnActionExecuting(
			ActionExecutingContext filterContext)
	{
		DocumentSession = DocumentStoreHolder.Store.
			OpenSession();
	}

	protected override void OnActionExecuted(
			ActionExecutedContext filterContext)
	{
		using (DocumentSession)
		{
			if (DocumentSession == null || 
				filterContext.Exception != null)
				return;
			DocumentSession.SaveChanges();
		}
	}
}

public abstract class BaseRavenDBApiController : ApiController
{
	public IAsyncDocumentSession DocumentSession { get; set; }

	public override async Task<HttpResponseMessage> ExecuteAsync(
			HttpControllerContext ctx, 
			CancellationToken cancel)
	{
		using (var session = DocumentStoreHolder.Store.OpenAsyncSession())
		{
			var message = await base.ExecuteAsync(ctx, cancel);
			await session.SaveChangesAsync();
			return message;
		}
	}
}
```

This tends to greatly simplify how we are actually working with the database, because we don't have to remember calling `SaveChanges` or manage the session ourselves. We also make sure that we have exactly one session for the duration of the request, which is also a good practice. In addition, this makes it very easy to test code that uses RavenDB. We'll talk about unit testing RavenDB code in Chapter 9.

With this, we conclude the public surface area of the session. Those methods allow us to do about 90% of everything that you could wish for with RavenDB. For the other 10%, we need to look at the `Advanced` property. 

#### Advanced

The surface area of the session was quite carefully designed so that the common operations were just a method call away from the session, and that there would be few of them. But while this covers a lot of the most common scenarios, that isn't enough for a high quality product like RavenDB.

All of the extra options are hiding inside the `Advanced` property. You can use that to configure the behavior of optimistic concurrency via:

	session.Advanced.UseOptimisticConcurrency = true;

Force a re-load an entity from the database to get the changes has been made there since that entity was loaded:

	session.Advanced.Refresh(product);

You can make the session forget about an entity:

	session.Advanced.Evict(product);

I'm not going to go over the `Advanced` options here. They are quite a few, and they are quite literally documented on the API itself. We'll on the relevant parts during the rest of the book. But it is still worth your time to inspect what else is there, even if you will rarely have to use that.

### Database commands

The session is a high level interface to RavenDB. It has the identity map, it has Linq queries, and it does pretty much everything so you won't have to deal with the low level stuff on a regular basis. But when you do, this is where the database commands come into place.

RavenDB is exposed over the network using a REST API. And you can absolutely make use of REST calls directly. We have several customers that are using REST calls from PowerShell to administer RavenDB. That is fine, and works great, but usually we can do better.

The Database Commands expose a low level API against RavenDB that is much nicer than raw REST calls. For example, I might want to check if a potentially large document exists, without loading it. I can do that using:

	var cmds = DocumentStoreHolder.Store.DatabaseCommands;
	var docMetadata = cmds.Head("products/1");
	if (docMetadata != null)
		Console.WriteLine("document exists");

You can use the Database Commands to get the database statistics, generate identity values, get the indexes and transformers on the server, issue patch commands, etc.

The reason that they are exposed to you is that the RavenDB API, at all levels, is built with the notion of layers. The expectation is that you'll usually work with the highest layer, the session API. But since we can't predict all things, we also provide access to the lower level API, on top of which the session API is built, so you can fall down to that if you need to.

For the most part, that is very rarely needed, but it is good to know that this is available, just in case.

### Working with async

So far, we have shown only synchronous work with the client API. But async support is crucial for high performance applications, and RavenDB has full support for that.
The async API is exposed via two major endpoints, the async session and the async database commands.

In all respects, they are identical to the sync versions. Listing 3.7 shows how we can save and load a document using the async session.

```{caption="Working with the async session" .cs }   
string productId;
using (var session = DocumentStoreHolder.Store.OpenAsyncSession())
{
	var product = new Product {Name = "Async Goodness"};
	await session.StoreAsync(product);
	productId = product.Id;

	await session.SaveChangesAsync();
}

using (var session = DocumentStoreHolder.Store.OpenAsyncSession())
{
	var product = await session.LoadAsync<Product>(productId);
	Console.WriteLine(product.Name);
}
```
Except for the `await` unary operators and the `Async` affixes, this is pretty much the same thing as the sync version. When querying using the async session, you use the `ToListAsync` method.

	var products = await session.Query<Product>()
		.Where(x => x.Name == "Async Goodness")
		.ToListAsync();

RavenDB splits the sync and async API because their use cases are quite different, and having separate APIs prevent you from doing some operations synchronously and some operations asynchronously. Because of that, you cannot mix and use the synchronous session with async calls, or vice versa. You can use either mode in your application, depending on the environment you are using. Aside from the minor required API changes, they are completely identical. 

The async support if very deep, all the way to the I/O issued to the server. In fact, the synchronous API is built on top of the async API and async I/O.

We covered the basics of working with the RavendB Client API in this section, but that was mostly the mechanics. We'll dive deeper into using RavenDB in the next chapter, where we'll also learn about the details and how it is all put together.

## Whatcha doin' with my data?

When you put data into RavenDB, where does it goes? Since RavenDB is transactional and ACID, the disk must be involved, but what exactly is going on there?

Server side RavenDB is built of layers, just like the client API. The data goes into RavenDB and eventually it reaches the storage engine layer. This storage engine is responsible for transactions, safety and isolation. It is there that RavenDB's safety originate from.

RavenDB ships with two storage engines. Esent and Voron. Both of them are ACID (Atomic, Consistent, Isolated and Durable), support snapshot isolation and has the kind of high performance RavenDB needs to deliver top notch service to your systems.

Esent stands for the Extensible Storage Engine (ESE), and it is also known as JET Blue. It is a core component in Windows, and forms the basis for services such as Active Directory, Exchange and many other Windows components. It is a robust and production tested storage engine, and has been used in RavenDB since the very start.

Voron (Russian for Raven) is an independently developed storage engine that was created by Hibernating Rhinos. It takes a lot from LevelDB and LMDB, but its internal structure is quite different. It is providing high performance read and writes and has full ACID support. Voron is our next generation storage technology, and it lies at the core of several upcoming features for RavenDB.

When you create a new database with RavenDB, you have the option of selecting the storage engine. Before RavenDB 3.0, you could had Esent as the storage engine. Now you have to make a choice. Esent has more time in the field, and in general has been proven to be a pretty good choice. It does suffer from several issues, chief among them is that you cannot easily move the database between machines. That is because Esent is tied to the Windows version, so you can't take a database from Windows 2012 server and open it on a Windows 8 machine. Another issue is that Esent is tied to the actual machine locale, and may require a defrag state when moving between machines with different locales.

Voron, on the other hand, was built to avoid all those issues, and you can move it between machines with no issues. It also tend to be faster than Esent for most purposes. Voron is optimized for 64 bits, and while it can run in 32 bits systems, its database size is very limited in those scenarios. Voron has also a lot less real world experience than Esent.

The conservative choice would be to go with Esent for the time being, even though Voron is what we are aiming at in the future. New features in RavenDB (distributed counters, event storage, etc.) are coming down the pipe that will be Voron only. And, of course, Hibernating Rhinos' own internal systems are running using Voron.

### Where is the data actually stored?

Regardless of the actual storage engine used, all the data is stored in a directory specified when creating the database. If a directory isn't specified, we'll use the following path: `$DataPath\Databases\$DbName`. The `$DataPath` is the default location for all the databases, usually that is the server executable location, but you can configure that using `Raven\DataDir` in the `App.config` file.

For more details about what is going on behind the scenes, you can look at Chapter 8, which talks about operations and production usage.

## Running in Production

So far, we have been running RavenDB in debug mode, as a console application. While this makes it very easy to run RavenDB, it is obviously not a suitable way to run RavenDB for production use. In production, we usually run RavenDB as an IIS Application or as a Windows Service.
	
> We'll cover RavenDB in production in a lot more depth in Chapter 8, Operations.

For production use, you can go to the [RavenDB Download Page](http://ravendb.net/download) and download the installer package. You can see how it looks in Figure 4.

![The RavenDB Installer](.\Ch03\Figure04.png)

This installer gives you the option of selecting a Windows Service or IIS, and takes care of all the details of installing RavenDB for you. Note that installing RavenDB for production use requires a license. You can also install RavenDB on your machine for development usage, which can be done without a license. 
An unlicensed copy of RavenDB cannot use authentication, and will consider any incoming request as those made by the system administrator. 

There isn't much of a difference between running RavenDB as IIS Application and as Windows Service. When running in IIS, you can take advantage of the additional monitoring capabilities that IIS provides. However, you are also saddled with its limitation (request length and time limits, startup/shutdown time quotas, etc.). When running as a Windows Service, RavenDB is responsible for  everything, including managing the HTTP layer. 

Running as part of a Windows Cluster require that you'll run as a Windows Service. But other than that, the preference tends to be to run in IIS for the additional tooling and management support that it provides.

## Summary

In this chapter, we talked about getting started with RavenDB. We installed RavenDB from scratch, then talked to it using the Document Store and Document Session. We have also explored the client API, what it can do and how to best utilize it.

You should have a single document store instance in your application, and use that to create a single session per request (or per message). We've also seen some sample code to handle that for common scenarios such as ASP.Net Web API and ASP.Net MVC. We covered how to do basic CRUD with RavenDB using the session and explored the layered structured of RavenDB. 

The session is the highest layer of the Client API, then we have the database commands and finally the raw REST calls over HTTP. That layered architecture is also present on the server side, and one such example is the storage engines that we looked at, Esent and Voron.

We touched briefly on running RavenDB in production, just to get you started, and we'll talk about this a lot more in Chapter 8, Operations. 

In the next chapter, we'll talk more about various concepts inside RavenDB. We'll see how everything is put together, and how you can best take advantage of that.
